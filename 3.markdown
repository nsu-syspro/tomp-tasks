## Задание №3

[![Очередная смешная картинка](https://imgs.xkcd.com/comics/the_general_problem.png)](https://xkcd.com/974/)

В качестве решения необходимо прислать скрипты в виде отдельных файлов, приложенных к письму.

Если вы являетесь фанатом не-bash, вполне можете использовать свой любимый шелл для скриптов.

1.  Как вы можете помнить, у `tar` не самые простые аргументы (см. [задание 1](1.markdown)). Создайте скрипт `untar.sh`, который принимает аргументом имя архива и распаковывает его в текущей папке.

1.  Для считывания из входного потока bash предоставляет встроенную команду `read`, которая аргументом принимает имя переменной и заносит в нее строку из входного потока.

        $ read foo
        abc def

        $ echo "$foo"
        abc def

    Единственный нюанс есть в том, как трактуются экранированные обратной косой чертой (бекслешем) символы:

        $ read one
        abc \n def

        $ echo "$one"
        abc n def

        $ read -r two
        abc \n def

        $ echo "$two"
        abc \n def

    Написать скрипт `head1`, который фильтрует входной поток, оставляя только первую строку (аналог `head -1`):

        $ cat .../block.txt | ./head1
        Ночь, улица, фонарь, аптека,

    Это не обязательно для сдачи задания, но напоминаю, что для запуска скрипта без указания пути нужно сложить его в какую-либо папку входящую в `$PATH`:

        $ mkdir ~/bin
        $ PATH="$HOME/bin:$PATH"
        $ cp ../head1 ~/bin/head1
        $ cat block.txt | head1
        Ночь, улица, фонарь, аптека,

1.  На самом деле bash может проводить [различные манипуляции с переменными во время их подстановки](https://devhints.io/bash#parameter-expansions). Например, с помощью `"${@:4}"` можно получить все аргументы, начиная с 4-го.

    Создать небольшой скрипт `batch_add_suffix.sh`, который принимает суффикс, список файлов и добавляет суффикс ко всем переданным файлам:

        $ ls -1
        for_brave_people.c
        hello.c
        hello.o
        hello.py
        hello.sh
        pure.c
        speed_is_not_critical.py
        tyap_lyap_i_sdaem.sh

        $ batch_add_suffix.sh '.bak' ./*.sh

        $ ls -1
        for_brave_people.c
        hello.c
        hello.o
        hello.py
        hello.sh.bak
        pure.c
        speed_is_not_critical.py
        tyap_lyap_i_sdaem.sh.bak

        $ batch_add_suffix.sh 'pp' hello.c for_brave_people.c

        $ ls -1
        for_brave_people.cpp
        hello.cpp
        hello.o
        hello.py
        hello.sh.bak
        pure.c
        speed_is_not_critical.py
        tyap_lyap_i_sdaem.sh.bak

    Опциональное доп. задание 1: убедиться, что файлы с пробелами в именах тоже корректно переименовываются.

    Опциональное доп. задание 2: добавить опцию `-v` (от английского "verbose"), которую можно указать до обязательных аргументов, при которой скрипт печатает на экран имена всех переименованных файлов.

1.  Заметим, что bash может проводить арифметические вычисления разными способами, например, внутри двойных скобочек:

        $ echo $((2 + 2 * 2))
        6

    Написать скрипт `fizzbuzz.sh`, который будет печатать все числа от 1 до 100. При этом:

    * Если число делится на 3, вместо числа напечатать `Fizz`,
    * Если число делится на 5, вместо числа напечатать `Buzz`,
    * Если число делится и на 3 и на 5, вместо числа напечатать `FizzBuzz`.

